// Generated by CoffeeScript 1.6.3
var ConnectionState, EventEmitter, FrameBuffer, Message, NSQDConnection, NodeState, StateChangeLogger, WriterConnectionState, WriterNSQDConnection, net, os, wire, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

net = require('net');

os = require('os');

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

NodeState = require('node-state');

FrameBuffer = require('./framebuffer');

Message = require('./message');

wire = require('./wire');

StateChangeLogger = require('./logging');

/*
NSQDConnection is a reader connection to a nsqd instance. It manages all
aspects of the nsqd connection with the exception of the RDY count which
needs to be managed across all nsqd connections for a given topic / channel
pair.

This shouldn't be used directly. Use a Reader instead.

Usage:

c = new NSQDConnection '127.0.0.1', 4150, 'test', 'default', 60, 30

c.on NSQDConnection.MESSAGE, (msg) ->
  console.log "Callback [message]: #{msg.attempts}, #{msg.body.toString()}"
  console.log "Timeout of message is #{msg.timeUntilTimeout()}"
  setTimeout (-> console.log "timeout = #{msg.timeUntilTimeout()}"), 5000
  msg.finish()

c.on NSQDConnection.FINISHED, ->
  c.setRdy 1

c.on NSQDConnection.READY, ->
  console.log "Callback [ready]: Set RDY to 100"
  c.setRdy 10

c.on NSQDConnection.CLOSED, ->
  console.log "Callback [closed]: Lost connection to nsqd"

c.on NSQDConnection.ERROR, (err) ->
  console.log "Callback [error]: #{err}"

c.on NSQDConnection.BACKOFF, ->
  console.log "Callback [backoff]: RDY 0"
  c.setRdy 0
  setTimeout (-> c.setRdy 100; console.log 'RDY 100'), 10 * 1000

c.connect()
*/


NSQDConnection = (function(_super) {
  __extends(NSQDConnection, _super);

  NSQDConnection.BACKOFF = 'backoff';

  NSQDConnection.CLOSED = 'closed';

  NSQDConnection.ERROR = 'error';

  NSQDConnection.FINISHED = 'finished';

  NSQDConnection.MESSAGE = 'message';

  NSQDConnection.REQUEUED = 'requeued';

  NSQDConnection.READY = 'ready';

  function NSQDConnection(nsqdHost, nsqdPort, topic, channel, requeueDelay, heartbeatInterval) {
    this.nsqdHost = nsqdHost;
    this.nsqdPort = nsqdPort;
    this.topic = topic;
    this.channel = channel;
    this.requeueDelay = requeueDelay;
    this.heartbeatInterval = heartbeatInterval;
    this.frameBuffer = new FrameBuffer();
    this.statemachine = this.connectionState();
    this.maxRdyCount = 0;
    this.msgTimeout = 0;
    this.maxMsgTimeout = 0;
    this.lastMessageTimestamp = null;
    this.lastReceivedTimestamp = null;
    this.conn = null;
    this.id = null;
  }

  NSQDConnection.prototype.connectionState = function() {
    return this.statemachine || new ConnectionState(this);
  };

  NSQDConnection.prototype.log = function(message) {
    return StateChangeLogger.log('NSQDConnection', this.statemachine.current_state_name, this.id, message);
  };

  NSQDConnection.prototype.connect = function() {
    var _this = this;
    return process.nextTick(function() {
      _this.conn = net.connect(_this.nsqdPort, _this.nsqdHost, function() {
        _this.id = _this.conn.localPort;
        return _this.statemachine.start();
      });
      _this.conn.on('data', function(data) {
        return _this.receiveData(data);
      });
      _this.conn.on('error', function(err) {
        return _this.statemachine.goto('ERROR', err);
      });
      return _this.conn.on('close', function() {
        return _this.statemachine.raise('close');
      });
    });
  };

  NSQDConnection.prototype.setRdy = function(rdyCount) {
    return this.statemachine.raise('ready', rdyCount);
  };

  NSQDConnection.prototype.receiveData = function(data) {
    var frameId, frames, payload, _i, _len, _ref, _results;
    this.lastReceivedTimestamp = Date.now();
    frames = this.frameBuffer.consume(data);
    _results = [];
    for (_i = 0, _len = frames.length; _i < _len; _i++) {
      _ref = frames[_i], frameId = _ref[0], payload = _ref[1];
      switch (frameId) {
        case wire.FRAME_TYPE_RESPONSE:
          _results.push(this.statemachine.raise('response', payload));
          break;
        case wire.FRAME_TYPE_ERROR:
          _results.push(this.statemachine.goto('ERROR', payload));
          break;
        case wire.FRAME_TYPE_MESSAGE:
          this.lastMessageTimestamp = this.lastReceivedTimestamp;
          _results.push(this.statemachine.raise('consumeMessage', this.createMessage(payload)));
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  };

  NSQDConnection.prototype.identify = function() {
    return {
      short_id: os.hostname().split('.')[0],
      long_id: os.hostname(),
      feature_negotiation: true,
      heartbeat_interval: this.heartbeatInterval * 1000
    };
  };

  NSQDConnection.prototype.createMessage = function(msgPayload) {
    var msg, msgComponents,
      _this = this;
    msgComponents = wire.unpackMessage(msgPayload);
    msg = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(Message, __slice.call(msgComponents).concat([this.requeueDelay], [this.msgTimeout], [this.maxMsgTimeout]), function(){});
    msg.on(Message.RESPOND, function(responseType, wireData) {
      _this.write(wireData);
      if (responseType === Message.FINISH) {
        return _this.emit(NSQDConnection.FINISHED);
      } else if (responseType === Message.REQUEUE) {
        return _this.emit(NSQDConnection.REQUEUED);
      }
    });
    msg.on(Message.BACKOFF, function() {
      return _this.emit(NSQDConnection.BACKOFF);
    });
    return msg;
  };

  NSQDConnection.prototype.write = function(data) {
    return this.conn.write(data);
  };

  NSQDConnection.prototype.destroy = function() {
    return this.conn.destroy();
  };

  return NSQDConnection;

})(EventEmitter);

ConnectionState = (function(_super) {
  __extends(ConnectionState, _super);

  function ConnectionState(conn) {
    this.conn = conn;
    ConnectionState.__super__.constructor.call(this, {
      autostart: false,
      initial_state: 'CONNECTED',
      sync_goto: true
    });
  }

  ConnectionState.prototype.log = function(message) {
    return this.conn.log(message);
  };

  ConnectionState.prototype.afterIdentify = function() {
    return 'SUBSCRIBE';
  };

  ConnectionState.prototype.states = {
    CONNECTED: {
      Enter: function() {
        return this.goto('SEND_MAGIC_IDENTIFIER');
      }
    },
    SEND_MAGIC_IDENTIFIER: {
      Enter: function() {
        this.conn.write(wire.MAGIC_V2);
        return this.goto('IDENTIFY');
      }
    },
    IDENTIFY: {
      Enter: function() {
        this.conn.write(wire.identify(this.conn.identify()));
        return this.goto('IDENTIFY_RESPONSE');
      }
    },
    IDENTIFY_RESPONSE: {
      response: function(data) {
        var identifyResponse;
        if (data === 'OK') {
          data = JSON.stringify({
            max_rdy_count: 2500,
            max_msg_timeout: 15 * 60 * 1000,
            msg_timeout: 60 * 1000
          });
        }
        identifyResponse = JSON.parse(data);
        this.conn.maxRdyCount = identifyResponse.max_rdy_count;
        this.conn.maxMsgTimeout = identifyResponse.max_msg_timeout;
        this.conn.msgTimeout = identifyResponse.msg_timeout;
        return this.goto(this.afterIdentify());
      }
    },
    SUBSCRIBE: {
      Enter: function() {
        this.conn.write(wire.subscribe(this.conn.topic, this.conn.channel));
        return this.goto('SUBSCRIBE_RESPONSE');
      }
    },
    SUBSCRIBE_RESPONSE: {
      response: function(data) {
        if (data.toString() === 'OK') {
          return this.goto('READY_RECV');
        }
      }
    },
    READY_RECV: {
      Enter: function() {
        return this.conn.emit(NSQDConnection.READY);
      },
      consumeMessage: function(msg) {
        return this.conn.emit(NSQDConnection.MESSAGE, msg);
      },
      response: function(data) {
        if (data.toString() === '_heartbeat_') {
          return this.conn.write(wire.nop());
        }
      },
      ready: function(rdyCount) {
        if (rdyCount > this.conn.maxRdyCount) {
          rdyCount = this.conn.maxRdyCount;
        }
        return this.conn.write(wire.ready(rdyCount));
      },
      close: function() {
        return this.goto('CLOSED');
      }
    },
    READY_SEND: {
      Enter: function() {
        return this.conn.emit(NSQDConnection.READY);
      },
      produceMessages: function(data) {
        var msgs, topic;
        topic = data[0], msgs = data[1];
        if (!_.isArray(msgs)) {
          throw new Error('Expect an array of messages to produceMessages');
        }
        if (msgs.length === 1) {
          return this.conn.write(wire.pub(topic, msgs[0]));
        } else {
          return this.conn.write(wire.mpub(topic, msgs));
        }
      },
      response: function(data) {
        if (data.toString() === '_heartbeat_') {
          return this.conn.write(wire.nop());
        }
      },
      close: function() {
        return this.goto('CLOSED');
      }
    },
    ERROR: {
      Enter: function(err) {
        this.conn.emit(NSQDConnection.ERROR, err);
        return this.goto('CLOSED');
      },
      close: function() {
        return this.goto('CLOSED');
      }
    },
    CLOSED: {
      Enter: function() {
        this.stop();
        this.conn.destroy();
        this.conn.emit(NSQDConnection.CLOSED);
        return this.conn = null;
      },
      close: function() {}
    }
  };

  ConnectionState.prototype.transitions = {
    '*': {
      '*': function(data, callback) {
        this.log('');
        return callback(data);
      },
      CONNECTED: function(data, callback) {
        this.log("" + this.conn.nsqdHost + ":" + this.conn.nsqdPort);
        return callback(data);
      },
      ERROR: function(err, callback) {
        this.log("" + err);
        return callback(err);
      }
    }
  };

  return ConnectionState;

})(NodeState);

/*
c = new NSQDConnectionWriter '127.0.0.1', 4150, 30
c.connect()

c.on NSQDConnectionWriter.CLOSED, ->
  console.log "Callback [closed]: Lost connection to nsqd"

c.on NSQDConnectionWriter.ERROR, (err) ->
  console.log "Callback [error]: #{err}"

c.on NSQDConnectionWriter.READY, ->
  c.produceMessages 'sample_topic', ['first message']
  c.produceMessages 'sample_topic', ['second message', 'third message']
  c.destroy()
*/


WriterNSQDConnection = (function(_super) {
  __extends(WriterNSQDConnection, _super);

  function WriterNSQDConnection(nsqdHost, nsqdPort, heartbeatInterval) {
    this.nsqdHost = nsqdHost;
    this.nsqdPort = nsqdPort;
    this.heartbeatInterval = heartbeatInterval;
    WriterNSQDConnection.__super__.constructor.call(this, this.nsqdHost, this.nsqdPort, null, null, 0, this.heartbeatInterval, false);
  }

  WriterNSQDConnection.prototype.connectionState = function() {
    return this.statemachine || new WriterConnectionState(this);
  };

  WriterNSQDConnection.prototype.produceMessages = function(topic, msgs) {
    return this.statemachine.raise('produceMessages', [topic, msgs]);
  };

  return WriterNSQDConnection;

})(NSQDConnection);

WriterConnectionState = (function(_super) {
  __extends(WriterConnectionState, _super);

  function WriterConnectionState() {
    _ref = WriterConnectionState.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  WriterConnectionState.prototype.afterIdentify = function() {
    return 'READY_SEND';
  };

  return WriterConnectionState;

})(ConnectionState);

module.exports = {
  NSQDConnection: NSQDConnection,
  ConnectionState: ConnectionState,
  WriterNSQDConnection: WriterNSQDConnection,
  WriterConnectionState: WriterConnectionState
};
