// Generated by CoffeeScript 1.6.3
var EventEmitter, NSQDConnection, Reader, ReaderRdy, RoundRobinList, lookup, request, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require('underscore');

request = require('request');

EventEmitter = require('events').EventEmitter;

NSQDConnection = require('./nsqdconnection').NSQDConnection;

ReaderRdy = require('./readerrdy').ReaderRdy;

RoundRobinList = require('./roundrobinlist');

lookup = require('./lookupd');

Reader = (function(_super) {
  __extends(Reader, _super);

  Reader.MESSAGE = 'message';

  Reader.DISCARD = 'discard';

  function Reader(topic, channel, options) {
    var anyNotEmpty, defaults, makeList, params, _ref;
    this.topic = topic;
    this.channel = channel;
    defaults = {
      name: null,
      maxInFlight: 1,
      heartbeatInterval: 30,
      maxBackoffDuration: 128,
      maxAttempts: 5,
      requeueDelay: 90,
      nsqdTCPAddresses: [],
      lookupdHTTPAddresses: [],
      lookupdPollInterval: 60,
      lookupdPollJitter: 0.3
    };
    params = _.extend({}, defaults, options);
    if (!(_.isString(topic) && topic.length > 0)) {
      throw new Error('Invalid topic');
    }
    if (!(_.isNumber(params.maxInFlight) && params.maxInFlight > 0)) {
      throw new Error('maxInFlight needs to be an integer greater than 0');
    }
    if (!(_.isNumber(params.heartbeatInterval) && params.heartbeatInterval > 0)) {
      throw new Error('heartbeatInterval needs to be an integer greater than 1');
    }
    if (!_.isNumber(params.maxBackoffDuration)) {
      throw new Error('maxBackoffDuration needs to be a number');
    }
    if (!(params.maxBackoffDuration > 0)) {
      throw new Error('maxBackoffDuration needs to be a number greater than 1');
    }
    if (!(params.name === null || _.isString(params.name))) {
      throw new Error('name needs to be unspecified or a string');
    }
    if (!_.isNumber(params.lookupdPollInterval)) {
      throw new Error('lookupdPollInterval needs to be a number');
    }
    if (!(0 <= params.lookupdPollInterval)) {
      throw new Error('lookupdPollInterval needs to be greater than 0');
    }
    if (!_.isNumber(params.lookupdPollJitter)) {
      throw new Error('lookupdPollJitter needs to be a number');
    }
    if (!((0 <= (_ref = params.lookupdPollJitter) && _ref <= 1))) {
      throw new Error('lookupdPollJitter needs to be between 0 and 1');
    }
    makeList = function(list) {
      var entry, _i, _len, _results;
      if (!_.isArray(list)) {
        list = [list];
      }
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        entry = list[_i];
        if (entry != null) {
          _results.push(entry);
        }
      }
      return _results;
    };
    params.nsqdTCPAddresses = makeList(params.nsqdTCPAddresses);
    params.lookupdHTTPAddresses = makeList(params.lookupdHTTPAddresses);
    anyNotEmpty = function() {
      var e, lst;
      lst = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _.some((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lst.length; _i < _len; _i++) {
          e = lst[_i];
          if (!_.isEmpty(e)) {
            _results.push(e);
          }
        }
        return _results;
      })());
    };
    if (!anyNotEmpty(params.nsqdTCPAddresses, params.lookupdHTTPAddresses)) {
      throw new Error('Need to specify either nsqdTCPAddresses or ' + 'lookupdHTTPAddresses option.');
    }
    params.name = params.name || ("" + topic + ":" + channel);
    params.requeueDelay = params.requeueDelay;
    params.heartbeatInterval = params.heartbeatInterval;
    _.extend(this, params);
    this.roundrobinLookupd = new RoundRobinList(this.lookupdHTTPAddresses);
    this.readerRdy = new ReaderRdy(this.maxInFlight, this.maxBackoffDuration);
    this.lookupdId = null;
    this.connectionIds = [];
  }

  Reader.prototype.connect = function() {
    var addr, address, delay, delayedStart, interval, port, _i, _len, _ref, _ref1,
      _this = this;
    if (!_.isEmpty(this.nsqdTCPAddresses)) {
      _ref = this.nsqdTCPAddresses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        addr = _ref[_i];
        _ref1 = addr.split(':'), address = _ref1[0], port = _ref1[1];
        this.connectToNSQD(address, Number(port));
      }
    }
    if (!this.lookupdHTTPAddresses) {
      return;
    }
    this.queryLookupd();
    interval = this.lookupdPollInterval * 1000;
    delayedStart = function() {
      return _this.lookupdId = setTimeout(_this.queryLookupd.bind(_this), interval);
    };
    delay = Math.random() * this.lookupdPollJitter * interval;
    return setTimeout(delayedStart, delay);
  };

  Reader.prototype.queryLookupd = function() {
    var endpoint,
      _this = this;
    endpoint = this.roundrobinLookupd.next();
    return lookup(endpoint, this.topic, function(err, nodes) {
      var n, _i, _len, _results;
      if (!err) {
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          n = nodes[_i];
          _results.push(_this.connectToNSQD(n.broadcast_address, n.tcp_port));
        }
        return _results;
      }
    });
  };

  Reader.prototype.connectToNSQD = function(host, port) {
    var conn, connectionId,
      _this = this;
    connectionId = "" + host + ":" + port;
    if (this.connectionIds.indexOf(connectionId) !== -1) {
      return;
    }
    this.connectionIds.push(connectionId);
    conn = new NSQDConnection(host, port, this.topic, this.channel, this.requeueDelay, this.heartbeatInterval);
    conn.on(NSQDConnection.CLOSED, function() {
      var index;
      index = _this.connectionIds.indexOf(connectionId);
      if (index === -1) {
        return;
      }
      return _this.connectionIds.splice(index, 1);
    });
    conn.on(NSQDConnection.MESSAGE, function(message) {
      return process.nextTick(function() {
        if (message.attempts < _this.maxAttempts) {
          return _this.emit(Reader.MESSAGE, message);
        } else {
          return _this.emit(Reader.DISCARD, message);
        }
      });
    });
    this.readerRdy.addConnection(conn);
    return conn.connect();
  };

  return Reader;

})(EventEmitter);

module.exports = Reader;
